'''
사이클 게임 - 두 명의 플레이어가 차례대로 돌아가며 진행하는 게임
선 플레이어가 홀수 번째 차례
후 플레이어가 짝수 번째 차례

0 ~ n - 1 까지 고유한 번호가 부여된 평면 상의 점 n개가 주어짐
이 중 어느 세 점도 일직선 위에 놓이지 않음
매 차례마다 플레이어는 두 점을 선택해서 이를 연결하는 선분을 그음
이미 그런 다른 선분과 교차하는 것은 가능
게임을 진행하다가 처음으로 사이클을 완성하는 순간 게임이 종료

사이클 c는 플레이어가 그린 선분들의 부분집합 
c에 속한 임의의 선분의 한 끝점에서 출발하여 모든 선분을 
한 번씩만 지나서 출발점으로 되돌아올 수 있음

선분을 여러 개 그리다 보면 사이클이 완성 되었는 지의 여부를 판단하기 어려워
이미 사이클이 완성되었음에도 불구하고 게임을 계속 진행하게 될 수 있다는 것

점의 개수 n과 m번째 차례까지의 게임 진행 상황이 주어지면 사이클이 완성되었는지 판단하고
완성되었다면 몇 번째 차례에서 처음으로 사이클이 완성된 것 출력하는 프로그램 작성

그럼 같은 집합인 점의 개수가 3개 이상이면 무조건 사이클 아닌가? => 마지막이 출발점 도착점 돌아온다면

예제 입력 :
6 5
0 1
1 2
2 3
5 4
0 4

6-5-4-0-1-2-3 
사이클 x
출력 : 0

6-5 0-1-2(3)
3 -0 
0 - 1 - 3 사이클

6 5 (점의 개수, 진행된 차례의 수) n,m으로 n은 점의 개수, m은 진행된 차례의 수
0 1
1 2
1 3
3 0 (여기서 사이클 완성)
2 3
5 4
0 4


0 1 2 3 4 5
0 1 2 3 4 5
#1 입력 : 0 1
0 0 2 3 4 5
#2 입력 : 1 2
0 0 0 3 4 5
#3 입력 : 1 3
0 0 0 0 4 5
#4 입력 : 3 0
0 0 0 0 4 5 : 전부 같은 집합에 속한 두 점이 들어왔기 때문에 여기서 사이클 생김
즉, 입력이 들어왔을 때 두 점이 같은 집합에 속한다면 => 사이클
두 점이 같은 집합에 속하지 않는다면 union find
'''
import sys
sys.setrecursionlimit(10**5)
def find(x):
    if arr[x] == x:
        return x
    
    arr[x] = find(arr[x])
    return arr[x]

def union(x, y):
    a = find(x)
    b = find(y)

    if a< b:
        arr[b] = a
    else:
        arr[a] = b        
    '''if a != b:
        arr[b] = a
'''
n,m = map(int, sys.stdin.readline().split())
flag = True
arr = [i for i in range (n)]

for i in range (m):   
    a,b = map(int, sys.stdin.readline().split())
    if find(arr[a]) == find(arr[b]) and flag == True:
        count = i
        flag = False
    else:
        union(a,b)

if flag == True:
    print(0)
else:
    print(count+1)